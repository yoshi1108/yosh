■1. DIなシステムに疲れ果てた。

・フレームワークの変更でDBスキーマが変わり動かなくなる。
→「xxx列が無い」というメッセージを見て、
  適当にVARCHR2でデカ目に切る
  →動かなければNUMBER型にしてみる

これの繰り返し。しかもその度デプロイしなおし（笑）
※これはDI関係ないだろ！確かに直接はそうだが...（詳しくは後述)

・「xxxのbean、DAOがない」というメッセージを見て、
膨大にあるJavaプロジェクトを文字検索する
「このもどかしさに懐かしさを感じる」と思っていたが、
これはBASICやCをeclise等の開発環境なしの
テキストエディタ&grepで開発していた時の
ルーティンワークに酷似している。

そして厄介なことに

           解決した時に変な達成感がある

が、これは
「BASICマガジンを打鍵しミス修正して動いた時の達成感」
「アキバで買ったジャンクを半田で直して動いた時の達成感」
と似た性質のものであり、本質的には不毛極まりない。
※趣味としては否定しない。事実、最近人が
　メチャクチャにしたmaven & springを
　「どうせこういう風に間違ってるんだろ？」
  と類推して修正してビルドが通って
  ×が無くなることが楽しくなってきている。:-)

悪い意味で過去に回帰している。

どうせ回帰するなら、maven , spring, jbossを捨てて、
素のソケット、せいぜいHTML、XML電文を投げて
対抗するシステムに回帰したらどうだろうか？
（というか、今だってザラにある構成だ）

Javaの静的型付け言語ならeclipseで一瞬で解決するし、
maven地獄など起こりえない。
まして、その状態でコミットするなんてことはありえない。

　　それがpom.xmlの不整合であれば起こる。

pom.xmlの設定不備による複数Javaプロジェクトビルド状態は
非常に複雑になりがちで
（わかればわかるほど基本はシンプルなのだが...)、
「うっかりpom.xmlとセントラルリポジトリ上の不整合」
を頻繁に起こし、そのままコミットされ、
それをチェックアウトする人々を混乱に陥れる。

　そういう事態に陥っているということ自体に
　気がつくのに３年間もかかった。

mavenを日常的、それこそ歯磨きする習慣レベルで当たり前に
利用して育ってきた人からすれば
「お前が馬鹿なだけ」なのだろうし、

　　　おっしゃる事ごもっともです

としか言いようがないのだが、
私のような者、それどころかそれ以下で、jenkinsが何なのか、
セントラルリポジトリが何のか
サッパリ分かってない人も多数いるだろう。

だが、管理者がそうではダメなのだ
（が、それを理解しろというのは酷だと思う）。

単に「全体のバージョンは0.0.2に統一しよう！」

とかいう表面上のコンセンサス決定すりゃいい訳ではない。


　　俺が、俺達がjenkinsだ！


とばかりに、ローカルにチェックアウトした膨大な数の
Javaプロジェクトのpom.xmlをサッとみてエラーを解決し、

「ふむ、これはxxxParentのバージョンが
そもそも先日決めたxxxと異なっていて、
YYYYプロジェクトはセントラルリポジトリと最新でずれてて、
最新側でないとhogehogeDaoがないのが問題だな。
よし、全体のバージョンを0.0.3に統一しよう」

みたいな意思決定ができないとダメなのである。

Jenkinsは一旦意思決定されたルール(pom.xml)に従い、
忠実に愚直に自動でプロジェクトをビルドするのであって、
「ダメダメなものを自動的にどうにかしてくれるシステム」
ではない。

pom.xmlレベルでの意思決定が管理者に求められるのである。

→けど、それはムリだろう
　→出来る人もいる？そいつは管理者としての素養に欠く(*1)
　　→∴maven & spring システムは失敗する

  ↑是非反論いただきたい（無論、現実的な対策込みで）。

*1:googleとかにはいる？そうだね、じゃあgoogleにいけよ。
　大体は技術を鼻にかけた高慢ちきな態度でおよそ
　全体を統制するとかいう素養から程遠い人が（褒め言葉です）
　フレームワークをローンチしている
　→その割を食う大勢の一般民という構造になる

・せっかくJunitのコードを書いてるのに、動かなくなる
フレームワークが変わり、コア部分に必要なDI要素の
追加、削除などがあり分かり得ない。
「仕様が変わって本体コードを修正したらテストコードが...」
みたいのは従来もあるが、
これは本来的に正しい流れで致し方ない。
※そもそも、途中で仕様が変わることが問題。別問題。

そして「フレームワークが変わりテストコードが...」
ということも従来からあるが、その回避が困難すぎる。
→理由：
　DIによる疎結が裏目にでて、
　コードやbean定義から類推できない。
　これがJavaのAPIライブラリの変更なら、eclipseで
　サッと解決するし、そもそもそんなものがリリース自体されない

はっきりいって、DI要素や入ってくるものが
勝手に追加・削除されたやつを類推で解決は不可能！！
※しかも動作させないとわかりません。

無論「連絡もなしに変わる」こと自体を問題とすべきだが、
発生するのだから仕方ない、発生するべきでない、
させないべき、というならその方法論を含めて反論願いたい。

利用者のレベルが低い(自分含む)ということなのかと
ずっと思い我慢してきたが、
分かってくれば分かってくるほどに
このspring & mavenシステムは

  作った（構成した？）奴にしか分からない加減を加速させている

とハッキリ感じるようになった。

spring & mavenそれ自体はいいのだが、
管理者が管理しきれない（しきれてないこと自体認識できない）
ことで管理がルーズになり、
よりルーズな内部IF上の変更を許す文化になりやすく
（これはいいことでもあるが、複雑な会社関係で
構成されがちがなPJでは致命的）
これを横断的に使ったプロジェクトがうまくいく道理がない
という結論に辿り着かざるを得ない。

  ↑是非反(ry (無論現実(ry

■1.5 最近勉強になったこと。

・Javaのテストコードのカバレッジを有効に活用できるようになった。
何が便利なのか本質的に分かり
”やらなければならないもの”ではなくなった。

試験してない箇所をコード上で配色して知らせてくれる
ツールの素晴らしさがわかるようになった、
つまり、それが契機で「うっかり試験してない箇所」を
気がつくことが多くなったのだ（そして8割方バグってる...)。
これは素晴らしい仕組みだなと痛感した。
※ユニットテストコードを当たり前のように精緻に
　書いているという前提がないと全く成り立たないが...

　　ハッキリいって、カバレッジ率なんてどうでもいい。

本当に試験しなければいけないところがコード上に表示され、
それに対する精緻な試験パターンを書いた結果、
カバレッジ率が100%に近くなるのである。

"100%に近くする作業"と"結果的に100%に近くなる"では、
カバレッジ率の数値は同じでも大違いである。

ということを実体験として理解できた。そして、

「意味もないテストコードでカバレッジ率を上げる」
のは有害だと悟った。

↑この意味が分かる人は、Junit系におけるユニットテスト、
カバレッジを表示するツール類の真の意味を理解している。
この意味が分からない人は
「ユニットテストコードはいやいや書くもので、
カバレッジ率は数値を上げて偉い人に作業エビデンスとして
求められている厄介なシロモノ」という認識だろう。
そんなもことならやらない方がいい（とはいってもヤレと
言われてるからやらないわけにはいかないが)

まあ、さきほどのmavenの件とは違い、
こちらは「偉い人」は分からないままでも問題ないだろうと思う。

・springがらみの設定異常パターン、解決の速度が上がった。

・mavenはキチンと使えれば便利だとわかった。jenkinsも。

・springで作ると単体テストし易いコードを
　書ける可能性が高まると分かった。
（ただし、膨大な工数がやはりかかるし、
　その工数は上位レイヤに説明不可能）

・仕事とまともに正対しているだけ
　馬鹿らしいと心の底から思えた。

■2. 何かおかしい、その原因と対策

「それは単に人の連絡、情報統制フレームワークがおかしい」

と単純に思っていたが、どうもそれだけではない。

というか、根本にその問題はあるが、
これはある程度どうしようもない。

自転車に鍵を掛けなければ盗まれるが、
「鍵をかけなかったから悪いのではない、盗む方が悪い」
確かにそうだが、それを言っていても仕方がない、同様に、
「情報統制がおかしいのが悪い」と言っていても仕方がない。

↑業界にいれば自然とこうなるよね。反論あんの？
というかむしろ反論いただきたい（無論、現実的な対策込みで）。

∴情報統制がおかしいのは仕方ない（大前提）

しかし、問題はspring & mavenシステムには
「情報統制がなってないことで、当たり前のように
コンパイルエラーとなっている状況を加速させる」
性質があるという結論に辿り着いた。

しつこいが道具は悪くない。

知れば知るほどにspringや
maven、jbossはDIやAOPという先進的な仕組みを
実現する素晴らしく良く出来た実装系であり、
それを否定する者はいないだろう。

※jboss5時代までは起動が遅かったがそれも過去のこと。
springはjava8辺りからjava自体にいろいろj2ee的ないろいろが追加されて
いろいろあるが、そういう細かいことは抜きにして。

日々コンパイルエラーになる毎日の中で、
mavenの仕組みや実際の操作の基本を知っていくにつれ、
mavenやjenkinsの偉大さ
「キチンと使ったら素晴らしいだろう」
ということはヒシヒシと感じる。

これが分からない人はmaven、jenkins、springを
単に嫌いか基礎的なことが分かってない。
※私にもそういう時期はあったし、みんなあるはずだと思う。
　私はかなりこの期間が長かったが。。。

だが、その時期はもう過ぎた。

過ぎた上で、maven,spring,jenkinsが
素晴らしいと分かった上での結論だが、

spring & mavenシステムの大きなプロジェクトは管理者が管理できない

管理者もmavenを熟知していなければ、管理もできない。

よって、情報統制が崩れることによる問題が発生しやすくなり、
その収拾を誰もつけないし、つけようともしないし、つけられない。
  
  ↑これは是非反論いただきたい（無論、現実的な対策込みで）。

■2. postgreSQLばっかやっててoracleでありがちなこと

・Oracle Sql Developer神すぎワロタｗｗｗ

・SQLワークシート内のcreate,update系でcommitを忘れる
→postgreSQLはデフォでautocommit ON だから。
　→逆も真なり。oracle -> postgreSQLの場合は逆でひどい目に合う、と。。。

■2. なぜspring & mavenシステムのプロジェクトが失敗するのか

■2.1

DIなシステムに疲れ果てたんだけど(笑)

シーザーだのjboss&springとかのDI(ダイナミックインジェクション？)を使ったシステム開発に辟易って話ね。

いやまあね、DI自体の概念は凄いし、実装系であるスプリングも凄い優秀なフレームとは思う。

DAOとかのORマッピングとかカッコいいとは思う。

そして「仕事に使うと便利なんだろうなと思った時期」もあったし、ダメな状態のプロジェクト進行になってるのはそこ固有な問題でありスプリングのせいではない、キチンと運用されれば良いだけなんだと思った。

が、うまく運用されることなどない。
そして、上手い上手くないというか、従来のシステム開発にあった「システムが縦割りになってて、責任境界がサーバやプロセス」というのではなく「DIされる部品単位が責任境界で一つのサーバ、プロセス(JVMとかね)に入る」システムみたいのばかりが生産されがちになるよね？

その結果、責任境界も曖昧になるし、作りづらくて仕方ない。

昨今のDIシステム(とザックリ呼んでしまうが)は、簡単な事を難しくしてしまってるプロジェクトばかりな気がするんだよね～

設定やらモジュールが「どこからどう設定されてくるのか」が作ったヤツにしか分からない(分かりづらい)。

ソースから動きが見えない、確かに内部粗結にできるから単体テストコードは書きやすい(時間をかければね…)。


やはり責任境界単位(つまり会社単位ね、下請けの)でサーバなりプロセスなどが分かれて、ソケットやらHTTP通信インターフェースで外部IFがあり、やりあう、というのがいいと思うんだよね。
まあDI関係なく今までも責任境界曖昧になる問題はあったけど、その問題の発生を助長し、例外なくデスマーチ化に導くのがjboss&springシステムだという気がしてきてます！！

作り手も面倒だけど、管理側もDI的な素養がないと上手くコントロールも出来ないと思うし。

というお話しでした。


繰り返しになるけど、jbossやspring自体は凄いし使えるものだと思ってるよ。
