■1. DIなシステムに疲れ果てた。

・フレームワークの変更でDBスキーマが変わり動かなくなる。
→「xxx列が無い」というメッセージを見て、
  適当にVARCHR2でデカ目に切る
  →動かなければNUMBER型にしてみる

これの繰り返し。しかもその度デプロイしなおし（笑）
※これはDI関係ない。確かに直接関係はないはずだが...（詳しくは後述)

・「xxxのbean、DAOがない」というメッセージを見て、
膨大にあるJavaプロジェクトを文字検索する
「このもどかしさに懐かしさを感じる」と思っていたが、
これはBASICやCをeclise等の開発環境なしの
テキストエディタ&grepで開発していた時の
ルーティンワークに酷似している。

そして厄介なことに

           解決した時に変な達成感がある

が、これは
「BASICマガジンを打鍵しミス修正して動いた時の達成感」
「アキバで買ったジャンクを半田で直して動いた時の達成感」
と似た性質のものであり、本質的には不毛極まりない。
※趣味としては否定しない。事実、最近人が
　メチャクチャにしたmaven & springを
　「どうせこういう風に間違ってるんだろ？」
  と類推して修正してビルドが通って
  ×が無くなることが楽しくなってきている。:-)

悪い意味で過去に回帰している。

どうせ回帰するなら、maven , spring, jbossを捨てて、
素のソケット、せいぜいHTML、XML電文を投げて
対抗するシステムに回帰したらどうだろうか？
（というか、今だってザラにある構成だ）

Javaの静的型付け言語ならeclipseで一瞬で解決するし、
maven地獄など起こりえない。
まして、その状態でコミットするなんてことはありえない。

　　それがpom.xmlの不整合であれば起こる。

pom.xmlの設定不備による複数Javaプロジェクトビルド状態は
非常に複雑になりがちで
（わかればわかるほど基本はシンプルなのだが...)、
「うっかりpom.xmlとセントラルリポジトリ上の不整合」
を頻繁に起こし、そのままコミットされ、
それをチェックアウトする人々を混乱に陥れる。

　そういう事態に陥っているということ自体に
　気がつくのに３年間もかかった。

mavenを日常的、それこそ歯磨きする習慣レベルで当たり前に
利用して育ってきた人からすれば
「お前が馬鹿なだけ」なのだろうし、

　　　おっしゃる事ごもっともです

としか言いようがないのだが、
私のような者、それどころかそれ以下で、jenkinsが何なのか、
セントラルリポジトリが何のか
サッパリ分かってない人も多数いるだろう。

だが、管理者がそうではダメなのだ
（が、それを理解しろというのは酷だと思う）。

単に「全体のバージョンは0.0.2に統一しよう！」

とかいう表面上のコンセンサス決定すりゃいい訳ではない。


　　俺が、俺達がjenkinsだ！


とばかりに、ローカルにチェックアウトした膨大な数の

「ふむ、これはxxxParentのバージョンが
そもそも先日決めたxxxと異なっていて、
YYYYプロジェクトはセントラルリポジトリと最新でずれてて、
最新側でないとhogehogeDaoがないのが問題だな。
よし、全体のバージョンを0.0.3に統一しよう」

みたいな意思決定ができないとダメなのである。

Jenkinsは一旦意思決定されたルール(pom.xml)に従い、
忠実に愚直に自動でプロジェクトをビルドするのであって、
「ダメダメなものを自動的にどうにかしてくれるシステム」
ではない。

pom.xmlレベルでの意思決定が管理者に求められるのである。

→けど、それはムリだろう
　→出来る人もいる？そいつは管理者としての素養に欠く(*1)
　　→∴maven & spring システムは失敗する

  ↑是非反論いただきたい（無論、現実的な対策込みで）。

*1:googleとかにはいる？そうだね、じゃあgoogleにいけよ。
　大体は技術を鼻にかけた高慢ちきな態度でおよそ
　全体を統制するとかいう素養から程遠い人が（褒め言葉です）
　フレームワークをローンチしている
　→その割を食う大勢の一般民という構造になる

・せっかくJunitのコードを書いてるのに、動かなくなる
フレームワークが変わり、コア部分に必要なDI要素の
追加、削除などがあり分かり得ない。
「仕様が変わって本体コードを修正したらテストコードが...」
みたいのは従来もあるが、
これは本来的に正しい流れで致し方ない。
※そもそも、途中で仕様が変わることが問題。別問題。

そして「フレームワークが変わりテストコードが...」
ということも従来からあるが、その回避が困難すぎる。
→理由：
　DIによる疎結が裏目にでて、
　コードやbean定義から類推できない。
　これがJavaのAPIライブラリの変更なら、eclipseで
　サッと解決するし、そもそもそんなものがリリース自体されない

はっきりいって、DI要素や入ってくるものが
勝手に追加・削除されたやつを類推で解決は不可能！！
※しかも動作させないとわかりません。

無論「連絡もなしに変わる」こと自体を問題とすべきだが、
発生するのだから仕方ない、発生するべきでない、
させないべき、というならその方法論を含めて反論願いたい。

利用者のレベルが低い(自分含む)ということなのかと
ずっと思い我慢してきたが、
分かってくれば分かってくるほどに
このspring & mavenシステムは

  作った（構成した？）奴にしか分からない加減を加速させている

とハッキリ感じるようになった。

管理者が管理しきれない（しきれてないこと自体認識できない）
ことで管理がルーズになり、
よりルーズな内部IF上の変更を許す文化になりやすく
（これはいいことでもあるが、複雑な会社関係で
構成されがちがなPJでは致命的）
これを横断的に使ったプロジェクトがうまくいく道理がない
という結論に辿り着かざるを得ない。

  ↑是非反(ry (無論現実(ry

■1.5 最近勉強になったこと。

・Javaのテストコードのカバレッジを有効に活用できるようになった。
何が便利なのか本質的に分かり
”やらなければならないもの”ではなくなった。

試験してない箇所をコード上で配色して知らせてくれる
ツールの素晴らしさがわかるようになった、
つまり、それが契機で「うっかり試験してない箇所」を
気がつくことが多くなったのだ（そして8割方バグってる...)。
これは素晴らしい仕組みだなと痛感した。
※ユニットテストコードを当たり前のように精緻に
　書いているという前提がないと全く成り立たないが...

　　ハッキリいって、カバレッジ率なんてどうでもいい。

本当に試験しなければいけないところがコード上に表示され、
それに対する精緻な試験パターンを書いた結果、
カバレッジ率が100%に近くなるのである。

"100%に近くする作業"と"結果的に100%に近くなる"では、
カバレッジ率の数値は同じでも大違いである。

ということを実体験として理解できた。そして、

「意味もないテストコードでカバレッジ率を上げる」
のは有害だと悟った。

↑この意味が分かる人は、Junit系におけるユニットテスト、
カバレッジを表示するツール類の真の意味を理解している。
この意味が分からない人は
「ユニットテストコードはいやいや書くもので、
カバレッジ率は数値を上げて偉い人に作業エビデンスとして
求められている厄介なシロモノ」という認識だろう。
そんなもことならやらない方がいい（とはいってもヤレと
言われてるからやらないわけにはいかないが)

まあ、さきほどのmavenの件とは違い、
こちらは「偉い人」は分からないままでも問題ないだろうと思う。

・springがらみの設定異常パターン、解決の速度が上がった。

・やはり能動的に動作するシミュレータはゴミ。CUIで送信電文を投げる、
　静的に起動して単に受信するだけ、こういうシミュレータが神。

　これは15年やってきて統計的に100%確実に言える。
　まずGUIの時点で8割方ゴミ判定して間違いないが、本質は
　「能動的に動作するか否か」

　能動的に動作するシミュレータは使い方、というか正常に動作させるのに
　非常に時間がかかり、動かないときに何がなんだかサッパリ分からない。
　動作させるのも大変だし、使いづらいし、「このコマンドをこう貼ったらいける」
　みたいな再現性もなければ、試験パターン等の制限が多い。
　（大体の場合、異常系が絶望的にできないし)　

　「能動的に動作したらかっけーーし、（俺は）便利だし！」

　という厨二病丸出しの作りの場合がほとんど。
　再現させるために待ったりしないといけなかったり。
　（ひどいと数十分もだ。そして、その周期を短くすればウザい動作になる）

　優れたシミュレータは「本物に近いこと」ではない。

　優れたシミュレータは

　【送信ツール】
   % hoge-tool.sh  -f 送信ファイル（とかシナリオファイル）
　【受信ツール】
   % hoge-dummy-sever.sh -f 設定ファイル(省略可能で相対パスにあるiniで動作）

  ↑これで100%いつも同じ動作を、やりたいときにすぐできる。これ。

  これ以外は作った奴以外に（使いづらい、制限がある、という様々観点)はゴ ミ
  →そして、作った奴がいなくなるのがこの業界の常
  　→例外なくゴミになる

　　　異論は認めない

　というか、これに異論する奴は今までにさんざんゴミを量産していて、
　困ってない(ここまでは仕方ないが）、そしてその自覚がないという酷い奴。

　絶対誰もが「GUIで周期的に動く難解なシミュレータ」
　に膨大な時間を浪費させられているはずなのだ。

・mavenはキチンと使えれば便利だとわかった。jenkinsも。

・springで作ると単体テストし易いコードを
　書ける可能性が高まると分かった。
（ただし、膨大な工数がやはりかかるし、
　その工数は上位レイヤに説明不可能）

■2. 何かおかしい、その原因と対策

「それは単に人の連絡、情報統制フレームワークがおかしい」

と単純に思っていたが、どうもそれだけではない。

というか、根本にはその問題はあるが、
これはある程度どうしようもない。

自転車に鍵を掛けなければ盗まれるが、
「鍵をかけなかったから悪いのではない、盗む方が悪い」
確かにそうだが、それを言っていても仕方がない。

 同様に、
「情報統制がおかしいのが悪い」と言っていても仕方がない。

↑業界にいれば自然とこうなるよね。反論あんの？
というかむしろ反論いただきたい（無論、現実的な対策込みで）。

∴情報統制がおかしいのは仕方ない（大前提）

しかし、問題はspring & mavenシステムには
「情報統制がなってないことで、当たり前のように
コンパイルエラーとなっている状況を加速させる」
性質があるという結論に辿り着いた。

しつこいが道具は悪くない。

知れば知るほどにspringや
maven、jbossはDIやAOPという先進的な仕組みを
実現する素晴らしく良く出来た実装系であり、
それを否定する者はいないだろう。

※jboss5時代までは起動が遅かったがそれも過去のこと。
springはjava8辺りからjava自体にいろいろj2ee的ないろいろが追加されて
いろいろあるが、そういう細かいことは抜きにして。

日々コンパイルエラーになる毎日の中で、
mavenの仕組みや実際の操作の基本を知っていくにつれ、
mavenやjenkinsの偉大さ
「キチンと使ったら素晴らしいだろう」
ということはヒシヒシと感じる。

これが分からない人はmaven、jenkins、springを
単に嫌いか基礎的なことが分かってない。
※私にもそういう時期はあったし、みんなあるはずだと思う。
　私はかなりこの期間が長かったが。。。

だが、その時期はもう過ぎた。

過ぎた上で、maven,spring,jenkinsが
素晴らしいと分かった上で、

spring & mavenシステムの大きなプロジェクトは管理者が管理できない

管理者もmavenを熟知していなければ、管理もできない。

よって、情報統制が崩れることによる問題が発生しやすくなり、
その収拾を誰もつけないし、つけようともしないし、つけられない。
  
  ↑是非反(ry 無論現(ry

■2. postgreSQLばっかやっててoracleでありがちなこと

・Oracle Sql Developer神すぎワロタｗｗｗ

・SQLワークシート内のcreate,update系でcommitを忘れる
→postgreSQLはデフォでautocommit ON だから。
　→逆も真なり。oracle -> postgreSQLの場合は逆でひどい目に合う、と。。。

■2. なぜspring & mavenシステムのプロジェクトが失敗するのか

■2.1

従来のシステム開発にあった
「システムが縦割りになってて、責任境界がサーバやプロセス」
というのではなく
「DIされる部品単位が責任境界で一つのサーバ、プロセス(JVMとかね)に入る」
システムみたいのばかりが生産されがちになるよね？

その結果、責任境界も曖昧になるし、作りづらくて仕方ない。

昨今のDIシステム(とザックリ呼んでしまうが)は、
簡単な事を難しくしてしまってるプロジェクトばかりな気がするんだよね～
作ったヤツにしか分からない(分かりづらい)。

ソースから動きが見えない、確かに内部粗結にできるから
単体テストコードは書きやすい(時間をかければね…)。


やはり責任境界単位(つまり会社単位ね、下請けの)でサーバなりプロセスなどが分かれて、
ソケットやらHTTP通信インターフェースで外部IFがあり、やりあう、
というのがいいと思うんだよね。
まあDI関係なく今までも責任境界曖昧になる問題はあったけど、
その問題の発生を助長し、
例外なくデスマーチ化に導くのがjboss&springシステムだという気がしてきてます！！

作り手も面倒だけど、管理側もDI的な素養がないと上手くコントロールも出来ないと思うし。

というお話しでした。

